{
  "title": "Typstに機能追加してみたい! (大規模OSSを手探る-進捗ブログ)",
  "closed": false,
  "archived": false,
  "created_at": "2024-10-08",
  "comments": [
    {
      "author": "htsulfuric",
      "created_at": "2024-10-08",
      "body_markdown": "## 2日目\n\n### なにをやるか\n- ソフトウェア: Typst\n- やりたいこと: LaTeXの`\\includegraphics`には`angle`オプションがあるが、typstの`image()`関数にはangleに類するオプションが無いため、その実装をめざしたい。~~え? angleオプション使ったことないって? 知らん~~\n\n### buildまで\nとりあえずgithubからTypstをクローンし[開発用のレポジトリ](https://github.com/doss-eeic/2024-04-typst.git)(プライベートだが)におく。\nhttps://github.com/typst/typst\nその後手元にpullしてbranchを切り、まずはbuildしてみた。\n```shell\n$ git clone git@github.com:path/to.git\n$ git branch dev\n$ git checkout dev  \n$ cargo build\nCompilling hoge\nCompilling fuwa\n…\nFinished `dev` profile [unoptimized + debuginfo] target(s) in 2m 55s\n```\n(意外と時間はかからなかったが)buildできた。これが実行できるか確認する。\n```shell\n$ ./target/debug/typst\nThe Typst compiler\n\nUsage: typst [OPTIONS] <COMMAND>\n…\n```\nビルドには無事成功したらしい。\n\n### 以降の目標\n- debuggerの準備:[ある記事](https://qiita.com/lechatthecat/items/c5444fdf0656cab6c0e4)曰くVS-Code上でrust-analyzerとCodeLLDBの組みあわせがよさそう?\n- rustの勉強: [rust本](https://doc.rust-jp.rs/book-ja/title-page.html)の所有権~構造体までは学びたい\n- 先駆者の記事を読む:[先駆者様](https://zenn.dev/taiiin02/articles/typst_articles_main#2.-typstのインストールと使い方)を参照してどのようなことをすればいいか把握する。\n- Typstの挙動確認: hoge.typをいれたときにどうなるかを確認。 [ここらへん](https://qiita.com/naoppy/items/55a0df837858e553d430) を参照\n\n### 雑談\nなんも考えずに`cargo build`を実行して`/target`を直下につくってしまったときには、git的に大変なことになってしまうのかと恐れたが、`.gitignore`で`/target`が無視になっていてたすかった。ありがとう`.gitignore`",
      "body_updated_at": "2024-10-08"
    },
    {
      "author": "htsulfuric",
      "created_at": "2024-10-15",
      "body_markdown": "## 3日目\n\nrustbookを読むだけの一日となった。第7章まで読んだので次回からはデバッギングに移行したい。\n\n> Rust:\n    Good for safety, need a PHD to print Hello World\n\n\n",
      "body_updated_at": "2024-10-15"
    },
    {
      "author": "htsulfuric",
      "created_at": "2024-10-15",
      "body_markdown": "## 4日目\n\n### デバッグ環境\nCodeLLDB + Rustを使用。`./.vscode/launch.JSON`以下に既に色々デバッグやユニットテストがあったが、今回は以下を追記した。\n```JSON:./vscode/launch.JSON\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"lldb\",\n            \"request\": \"launch\",\n            \"name\": \"Debug /target/debug/typst\",\n            \"program\": \"${workspaceFolder}/target/debug/typst\",\n            \"args\": [\"compile\", \"/path/to/*.typ\"],\n            \"cwd\": \"${workspaceFolder}\",\n            \"sourceLanguages\": [\"rust\"],\n            \"preLaunchTask\": \"rust: cargo build\",\n        }\n    ],\n    \"rust-analyzer.linkedProjects\": [\"${workspaceFolder}/Cargo.toml\"],\n}\n```\n\n### とりあえずわかったこと\n```rust: typst-cli/src/main.rs\nfn main() -> ExitCode {\n    let res = dispatch();\n\n    if let Err(msg) = res {\n        set_failed();\n        print_error(msg.message()).expect(\"failed to print error\");\n    }\n\n    EXIT.with(|cell| cell.get())\n}\n```\nから開始。 `dispatch()`内でErrorが返されたら`print_Error`をして`Exit`。つまりコンパイルは`dispatch()`内でおこってる。\n\n```rust: typst-cli/main.rs\nfn dispatch() -> HintedStrResult<()> {\n    let timer = Timer::new(&ARGS);\n\n    match &ARGS.command {\n        Command::Compile(command) => crate::compile::compile(timer, command.clone())?,\n        Command::Watch(command) => crate::watch::watch(timer, command.clone())?,\n        Command::Init(command) => crate::init::init(command)?,\n        Command::Query(command) => crate::query::query(command)?,\n        Command::Fonts(command) => crate::fonts::fonts(command),\n        Command::Update(command) => crate::update::update(command)?,\n    }\n\n    Ok(())\n}\n```\nわかりやすいMatch文がでてきた。しかもこのMatch文、`typst`に変数を渡さずに走らせたときにでるヘルプとまったく同じ。\n![typst_1](https://storage.googleapis.com/zenn-user-upload/8540dbf6aa13-20241015.png)\n*ほなこのMatchでコマンドみてるんやろ*\n\nじゃあ渡されているARGSは何だろうと思って、型の`CliArgument`を見にいく\n\n```rust: typst-cli/src/args.rs\npub struct CliArguments {\n    /// The command to run\n    #[command(subcommand)]\n    pub command: Command,\n\n    /// Set when to use color.\n    /// auto = use color if a capable terminal is detected\n    #[clap(\n        long,\n        value_name = \"WHEN\",\n        require_equals = true,\n        num_args = 0..=1,\n        default_value = \"auto\",\n        default_missing_value = \"always\",\n    )]\n    pub color: ColorChoice,\n\n    /// Path to a custom CA certificate to use when making network requests.\n    #[clap(long = \"cert\", env = \"TYPST_CERT\")]\n    pub cert: Option<PathBuf>,\n}\n```\n\n#[hoge]はattributeでメタデータに関するものなので今回は無視。 `&ARGS.command `にmatch構文が適用されていて、`pub command: Command`と宣言されているので`Command`型を見てくるとする。\n\n```rust: typst-cli/src/args.rs\npub enum Command {\n    /// Compiles an input file into a supported output format\n    #[command(visible_alias = \"c\")]\n    Compile(CompileCommand),\n\n    /// Watches an input file and recompiles on changes\n    #[command(visible_alias = \"w\")]\n    Watch(CompileCommand),\n\n    /// Initializes a new project from a template\n    Init(InitCommand),\n\n    /// Processes an input file to extract provided metadata\n    Query(QueryCommand),\n\n    /// Lists all discovered fonts in system and custom font paths\n    Fonts(FontsCommand),\n\n    /// Self update the Typst CLI\n    #[cfg_attr(not(feature = \"self-update\"), clap(hide = true))]\n    Update(UpdateCommand),\n}\n```\n\n~~また関数宣言かよ~~ 愚痴っても仕方ない、`CompileCommand`を見にいく。\n\n```rust: typst-cli/src/args.rs\npub struct CompileCommand {\n    /// Shared arguments\n\n    pub common: SharedArgs,\n\n    /// Path to output file (PDF, PNG or SVG). Use `-` to write output to stdout.\n\n    pub output: Option<Output>,\n\n    pub pages: Option<Vec<PageRangeArgument>>,\n\n    /// Output a Makefile rule describing the current compilation\n\n    pub make_deps: Option<PathBuf>,\n\n    /// The format of the output file, inferred from the extension by default\n\n    pub format: Option<OutputFormat>,\n\n    /// Opens the output file with the default viewer or a specific program after compilation\n\n    pub open: Option<Option<String>>,\n\n    /// The PPI (pixels per inch) to use for PNG export\n\n    pub ppi: f32,\n\n    /// Produces performance timings of the compilation process (experimental)\n\n    pub timings: Option<Option<PathBuf>>,\n\n    /// One (or multiple comma-separated) PDF standards that Typst will enforce conformance with.\n\n    pub pdf_standard: Vec<PdfStandard>,\n}\n```\n(長かったためコメントとメタデータを一部切り取り)\nとてもそれっぽいものに遭遇した。 しかしTypstのコードは注釈も多くて読みやすい。今回は`SharedArgs`以下にありそう。\n\n```rust: typst-cli/src/args.rs\npub struct SharedArgs {\n    /// Path to input Typst file. Use `-` to read input from stdin\n\n    pub input: Input,\n\n    /// Configures the project root (for absolute paths)\n\n    pub root: Option<PathBuf>,\n\n    /// Add a string key-value pair visible through `sys.inputs`\n\n    pub inputs: Vec<(String, String)>,\n\n    /// Common font arguments\n\n    pub font_args: FontArgs,\n\n    /// The document's creation date formatted as a UNIX timestamp.\n\n    pub creation_timestamp: Option<DateTime<Utc>>,\n\n    /// The format to emit diagnostics in\n\n    pub diagnostic_format: DiagnosticFormat,\n\n    /// Arguments related to storage of packages in the system\n\n    pub package_storage_args: PackageStorageArgs,\n\n    /// Number of parallel jobs spawned during compilation,  defaults to number of CPUs. Setting it to 1 disables parallelism.\n    pub jobs: Option<usize>,\n}\n```\n\nと、ここまで入力を探ってて今気づいたのだが、\n\n**別に入力の処理追っても`#image`関数の動作と関係なくないか???**\n\nということで戻ってサクっとmatch文の先に行くとしましょう(45minロス)\n\n```rust:typst-cli/main.rs (再掲)\nfn dispatch() -> HintedStrResult<()> {\n    let timer = Timer::new(&ARGS);\n\n    match &ARGS.command {\n        Command::Compile(command) => crate::compile::compile(timer, command.clone())?,\n        Command::Watch(command) => crate::watch::watch(timer, command.clone())?,\n        Command::Init(command) => crate::init::init(command)?,\n        Command::Query(command) => crate::query::query(command)?,\n        Command::Fonts(command) => crate::fonts::fonts(command),\n        Command::Update(command) => crate::update::update(command)?,\n    }\n\n    Ok(())\n}\n```\n今回は`Command::Compile(command)`にmatchするので` crate::compile::compile(timer, command.clone())`が走るはず。(ちなみに後ろに付いてる`?`は`Err`を受けとったときに関数の返り値を`Err`とする すげぇ)。\n\n```rust:typst-cli/src/args.rs\npub struct CompileCommand {\n    /// Shared arguments\n    #[clap(flatten)]\n    pub common: SharedArgs,\n\n...\n```\n\n*あれ?* \nと思ったが`command.clone()`が先に走ったからこちらに潜ることとなったらしい。ということでとっとと抜けだしてもう一度潜ってみる。\n\n```rust:typst-cli/src/compile.rs\npub fn compile(mut timer: Timer, mut command: CompileCommand) -> StrResult<()> {\n    // Only meant for input validation\n    _ = command.output_format()?;\n\n    let mut world =\n        SystemWorld::new(&command.common).map_err(|err| eco_format!(\"{err}\"))?;\n    timer.record(&mut world, |world| compile_once(world, &mut command, false))??;\n    Ok(())\n}\n```\n\nそれっぽい! とりあえず`output_format()`で`Output`型をさわっているのでその確認をしにいく。\n\n```rust:typst-cli/src/args.rs\npub enum Output {\n    /// Stdout, represented by `-`.\n    Stdout,\n    /// A non-empty path.\n    Path(PathBuf),\n}\n```\n出力先を`stdout`にするか`Path(pdf他)`にするだけっぽい。 とりあえずスルーして先に行けそう。\n\n`let mut world =\n        SystemWorld::new(&command.common).map_err(|err| eco_format!(\"{err}\"))?;`\nなかなかに圧のある文章だが、 SystemWorld型以下に設定されているnew関数に`command.common`を渡して、失敗したらエラー処理のように読める(多分) なのでとりあえずSystemWorld型とnew関数を見にいこう。\n\n```rust:typst-cli/src/World.rs\n/// A world that provides access to the operating system.\npub struct SystemWorld {\n    /// The working directory.\n    workdir: Option<PathBuf>,\n    /// The root relative to which absolute paths are resolved.\n    root: PathBuf,\n    /// The input path.\n    main: FileId,\n    /// Typst's standard library.\n    library: LazyHash<Library>,\n    /// Metadata about discovered fonts.\n    book: LazyHash<FontBook>,\n    /// Locations of and storage for lazily loaded fonts.\n    fonts: Vec<FontSlot>,\n    /// Maps file ids to source files and buffers.\n    slots: Mutex<HashMap<FileId, FileSlot>>,\n    /// Holds information about where packages are stored.\n    package_storage: PackageStorage,\n    /// The current datetime if requested. This is stored here to ensure it is\n    /// always the same within one compilation.\n    /// Reset between compilations if not [`Now::Fixed`].\n    now: Now,\n    /// The export cache, used for caching output files in `typst watch`\n    /// sessions.\n    export_cache: ExportCache,\n}\n\npub fn new(command: &SharedArgs) -> Result<Self, WorldCreationError> {\n        // Set up the thread pool.\n        if let Some(jobs) = command.jobs {\n            rayon::ThreadPoolBuilder::new()\n                .num_threads(jobs)\n                .use_current_thread()\n                .build_global()\n                .ok();\n        }\n\n        // Resolve the system-global input path.\n        let input = match &command.input {\n            Input::Stdin => None,\n            Input::Path(path) => {\n                Some(path.canonicalize().map_err(|err| match err.kind() {\n                    io::ErrorKind::NotFound => {\n                        WorldCreationError::InputNotFound(path.clone())\n                    }\n                    _ => WorldCreationError::Io(err),\n                })?)\n            }\n        };\n\n        // Resolve the system-global root directory.\n        let root = {\n            let path = command\n                .root\n                .as_deref()\n                .or_else(|| input.as_deref().and_then(|i| i.parent()))\n                .unwrap_or(Path::new(\".\"));\n            path.canonicalize().map_err(|err| match err.kind() {\n                io::ErrorKind::NotFound => {\n                    WorldCreationError::RootNotFound(path.to_path_buf())\n                }\n                _ => WorldCreationError::Io(err),\n            })?\n        };\n\n        let main = if let Some(path) = &input {\n            // Resolve the virtual path of the main file within the project root.\n            let main_path = VirtualPath::within_root(path, &root)\n                .ok_or(WorldCreationError::InputOutsideRoot)?;\n            FileId::new(None, main_path)\n        } else {\n            // Return the special id of STDIN otherwise\n            *STDIN_ID\n        };\n\n        let library = {\n            // Convert the input pairs to a dictionary.\n            let inputs: Dict = command\n                .inputs\n                .iter()\n                .map(|(k, v)| (k.as_str().into(), v.as_str().into_value()))\n                .collect();\n\n            Library::builder().with_inputs(inputs).build()\n        };\n\n        let fonts = Fonts::searcher()\n            .include_system_fonts(!command.font_args.ignore_system_fonts)\n            .search_with(&command.font_args.font_paths);\n\n        let now = match command.creation_timestamp {\n            Some(time) => Now::Fixed(time),\n            None => Now::System(OnceLock::new()),\n        };\n\n        Ok(Self {\n            workdir: std::env::current_dir().ok(),\n            root,\n            main,\n            library: LazyHash::new(library),\n            book: LazyHash::new(fonts.book),\n            fonts: fonts.fonts,\n            slots: Mutex::new(HashMap::new()),\n            package_storage: package::storage(&command.package_storage_args),\n            now,\n            export_cache: ExportCache::new(),\n        })\n    }\n\n\n...\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "body_updated_at": "2024-10-15"
    },
    {
      "author": "htsulfuric",
      "created_at": "2024-10-21",
      "body_markdown": "### 5日目\n\n**【悲報】main.rs から追ってたら時間がたりない!**\n\n**【悲報2】#rotate functionを見付けました!**\n\n……どーすんだこれ\n\n\nと、いってても仕方ないので一つずつ対処していきましょう。\n\n#### main.rsからでは時間が足りない\n\nそのためのファイル全探索。`image`で検索をかけてみる。\n\n![image_func](https://storage.googleapis.com/zenn-user-upload/f4bdac15470d-20241021.png)\n*あっ!(ターン)*\n\nいた。\n\nとりあえずこっちは解決ということで、もうひとつの問題に目をむけなけねば。\n\n\n#### rotate functionがあった\n\nいやまぁ、 ありますよね……\n\nhttps://typst.app/docs/reference/layout/rotate/\n\nさてどうしましょうか、というところでこんなことに気付いた。\n\nある画像を回転しながらcaptionをつけるという、いかにもやりそうなことをしてみる。\n```typst:test.typ\n#figure(\n  rotate(90deg, image(\"not_desired_behavior.png\")),\n  caption: [ Not desired behavior ],\n)\n```\n\nするとこうなる。\n\n![crab](https://storage.googleapis.com/zenn-user-upload/b96d8f37b322-20241021.png)\n*not_desired_behavior*\n\n**あれ?**\n\nどうもリサイズが自動で効かないようである。 また、`#figure`や`#rotate`のサイズの最適化オプションもうまくいかないようだ。\n\nということで、ここからは開発目標を\n\n`#figure`引数内で呼びだされた画像でも形を枠内でおさめる\n\nことにする。\n\n\nということで、`image/`以下を探っていくことにするが、それはまた次回の話(進捗ダメです)\n\n\n\n\n"
    },
    {
      "author": "htsulfuric",
      "created_at": "2024-10-22",
      "body_markdown": "## 6日目\n\n今更(?)であるが、Typstのコンパイルの道筋を確認しよう\n\n```rust:typst/src/lib.rs\n//! The compiler for the _Typst_ markup language.\n//!\n//! # Steps\n//! - **Parsing:**\n//!   The compiler first transforms a plain string into an iterator of [tokens].\n//!   This token stream is [parsed] into a [syntax tree]. The tree itself is\n//!   untyped, but the [AST] module provides a typed layer over it.\n//! - **Evaluation:**\n//!   The next step is to [evaluate] the markup. This produces a [module],\n//!   consisting of a scope of values that were exported by the code and\n//!   [content], a hierarchical, styled representation of what was written in\n//!   the source file. The elements of the content tree are well structured and\n//!   order-independent and thus much better suited for further processing than\n//!   the raw markup.\n//! - **Layouting:**\n//!   Next, the content is [layouted] into a [document] containing one [frame]\n//!   per page with items at fixed positions.\n//! - **Exporting:**\n//!   These frames can finally be exported into an output format (currently PDF,\n//!   PNG, or SVG).\n//!\n//! [tokens]: syntax::SyntaxKind\n//! [parsed]: syntax::parse\n//! [syntax tree]: syntax::SyntaxNode\n//! [AST]: syntax::ast\n//! [evaluate]: eval::eval\n//! [module]: foundations::Module\n//! [content]: foundations::Content\n//! [layouted]: crate::layout::layout_document\n//! [document]: model::Document\n//! [frame]: layout::Frame\n```\n\nつまり、今回の問題はEvaluation と Layoutの辺りでおこっていると考えられる。\n\n参照するために`rotate`関数の中身を覗こう。\n\n```rust:typst/src/layout/transform.rs\n/// Rotates content without affecting layout.\n///\n/// Rotates an element by a given angle. The layout will act as if the element\n/// was not rotated unless you specify `{reflow: true}`.\n///\n/// # Example\n/// ```example\n/// #stack(\n///   dir: ltr,\n///   spacing: 1fr,\n///   ..range(16)\n///     .map(i => rotate(24deg * i)[X]),\n/// )\n/// ```\n#[elem(Show)]\npub struct RotateElem {\n    /// The amount of rotation.\n    ///\n    /// ```example\n    /// #rotate(-1.571rad)[Space!]\n    /// ```\n    ///\n    #[positional]\n    pub angle: Angle,\n\n    /// The origin of the rotation.\n    ///\n    /// If, for instance, you wanted the bottom left corner of the rotated\n    /// element to stay aligned with the baseline, you would set it to `bottom +\n    /// left` instead.\n    ///\n    /// ```example\n    /// #set text(spacing: 8pt)\n    /// #let square = square.with(width: 8pt)\n    ///\n    /// #box(square())\n    /// #box(rotate(30deg, origin: center, square()))\n    /// #box(rotate(30deg, origin: top + left, square()))\n    /// #box(rotate(30deg, origin: bottom + right, square()))\n    /// ```\n    #[fold]\n    #[default(HAlignment::Center + VAlignment::Horizon)]\n    pub origin: Alignment,\n\n    /// Whether the rotation impacts the layout.\n    ///\n    /// If set to `{false}`, the rotated content will retain the bounding box of\n    /// the original content. If set to `{true}`, the bounding box will take the\n    /// rotation of the content into account and adjust the layout accordingly.\n    ///\n    /// ```example\n    /// Hello #rotate(90deg, reflow: true)[World]!\n    /// ```\n    #[default(false)]\n    pub reflow: bool,\n\n    /// The content to rotate.\n    #[required]\n    pub body: Content,\n}\n\nimpl Show for Packed<RotateElem> {\n    fn show(&self, _: &mut Engine, _: StyleChain) -> SourceResult<Content> {\n        Ok(BlockElem::single_layouter(self.clone(), layout_rotate)\n            .pack()\n            .spanned(self.span()))\n    }\n}\n\n/// Layout the rotated content.\n#[typst_macros::time(span = elem.span())]\nfn layout_rotate(\n    elem: &Packed<RotateElem>,\n    engine: &mut Engine,\n    locator: Locator,\n    styles: StyleChain,\n    region: Region,\n) -> SourceResult<Frame> {\n    let angle = elem.angle(styles);\n    let align = elem.origin(styles).resolve(styles);\n\n    // Compute the new region's approximate size.\n    let size = if region.size.is_finite() {\n        compute_bounding_box(region.size, Transform::rotate(-angle)).1\n    } else {\n        Size::splat(Abs::inf())\n    };\n\n    measure_and_layout(\n        engine,\n        locator,\n        region,\n        size,\n        styles,\n        elem.body(),\n        Transform::rotate(angle),\n        align,\n        elem.reflow(styles),\n    )\n}\n```\n\n返り値にあたる`measure_and_layout`が`frame`型をもっているをもっているので、ここがどういう挙動をしているかを見てみたい。\n\n```rust:typst/src/layout/transorm.rs\nfn measure_and_layout(\n    engine: &mut Engine,\n    locator: Locator,\n    region: Region,\n    size: Size,\n    styles: StyleChain,\n    body: &Content,\n    transform: Transform,\n    align: Axes<FixedAlignment>,\n    reflow: bool,\n) -> SourceResult<Frame> {\n    if reflow {\n        // Measure the size of the body.\n        let pod = Region::new(size, Axes::splat(false));\n        let frame = layout_frame(engine, body, locator.relayout(), styles, pod)?;\n\n        // Actually perform the layout.\n        let pod = Region::new(frame.size(), Axes::splat(true));\n        let mut frame = layout_frame(engine, body, locator, styles, pod)?;\n        let Axes { x, y } = align.zip_map(frame.size(), FixedAlignment::position);\n\n        // Compute the transform.\n        let ts = Transform::translate(x, y)\n            .pre_concat(transform)\n            .pre_concat(Transform::translate(-x, -y));\n\n        // Compute the bounding box and offset and wrap in a new frame.\n        let (offset, size) = compute_bounding_box(frame.size(), ts);\n        frame.transform(ts);\n        frame.translate(offset);\n        frame.set_size(size);\n        Ok(frame)\n    } else {\n        // Layout the body.\n        let mut frame = layout_frame(engine, body, locator, styles, region)?;\n        let Axes { x, y } = align.zip_map(frame.size(), FixedAlignment::position);\n\n        // Compute the transform.\n        let ts = Transform::translate(x, y)\n            .pre_concat(transform)\n            .pre_concat(Transform::translate(-x, -y));\n\n        // Apply the transform.\n        frame.transform(ts);\n        Ok(frame)\n    }\n}\n```\n\n`reflow`が重要な分岐を任されているっぽい。 あれ、でもそんな変数をみた記憶が……\n\n![reflow](https://storage.googleapis.com/zenn-user-upload/cd8c15d6a9b8-20241022.png)\n*あっ*\n\nいた。 しかもなんか重要なこと書いてある。  なんか猛烈に嫌な予感がする……\n\n```rust: test.typ\n#figure(\n  rotate(90deg, image(\"not_desired_behavior.png\"), reflow: true),\n  caption: [ Not desired behavior ],\n)\n```\n\n![desired_behavior](https://storage.googleapis.com/zenn-user-upload/ed9fbfb41b44-20241022.png)\n*あっ*\n\n**できちゃった**\n\n……\n\n気をとりなおそう……\n\n### 目標変更\n\nとりあえず`#rotate`関数は思ったより優秀だった。 そして私達が考えることぐらい先に誰かがやっていることを痛感した ~~そりゃそうじゃ~~\n\nよってこれからは\n**`#image関数`からでもrotateできるようにする**\n\nを新たな目標とする。\n\nそのためには\n\n- フレームワークの設定\n- 回転をどうやっているか\n\nを見ていこう。\n\n\n### なんかできちゃった\n\nとりあえず先日みつけた`image`以下`mod.rs`を眺めてみる。\n\n```rust:typst/src/visualize/image/mod.rs\npub struct ImageElem {\n    /// Path to an image file\n    ///\n    /// For more details, see the [Paths section]($syntax/#paths).\n    #[required]\n    #[parse(\n        let Spanned { v: path, span } =\n            args.expect::<Spanned<EcoString>>(\"path to image file\")?;\n        let id = span.resolve_path(&path).at(span)?;\n        let data = engine.world.file(id).at(span)?;\n        path\n    )]\n    #[borrowed]\n    pub path: EcoString,\n\n    /// The raw file data.\n    #[internal]\n    #[required]\n    #[parse(Readable::Bytes(data))]\n    pub data: Readable,\n\n    /// The image's format. Detected automatically by default.\n    ///\n    /// Supported formats are PNG, JPEG, GIF, and SVG. Using a PDF as an image\n    /// is [not currently supported](https://github.com/typst/typst/issues/145).\n    pub format: Smart<ImageFormat>,\n\n    /// The width of the image.\n    pub width: Smart<Rel<Length>>,\n\n    /// The height of the image.\n    pub height: Sizing,\n\n    /// A text describing the image.\n    pub alt: Option<EcoString>,\n\n    /// How the image should adjust itself to a given area (the area is defined\n    /// by the `width` and `height` fields). Note that `fit` doesn't visually\n    /// change anything if the area's aspect ratio is the same as the image's\n    /// one.\n    ///\n    /// ```example\n    /// #set page(width: 300pt, height: 50pt, margin: 10pt)\n    /// #image(\"tiger.jpg\", width: 100%, fit: \"cover\")\n    /// #image(\"tiger.jpg\", width: 100%, fit: \"contain\")\n    /// #image(\"tiger.jpg\", width: 100%, fit: \"stretch\")\n    /// ```\n    #[default(ImageFit::Cover)]\n    pub fit: ImageFit,\n}\n```\n\nこれは[#rotate関数の引数](https://typst.app/docs/reference/layout/rotate/)と合致しているので、どうやらここで型定義していそうである。\n\nそのまま`image/`以下を探していると、`rotate`という文字が`raster.rs`以下にいた。\n\n```rust: typst/src/visualize/image/raster.rs\n/// Apply an EXIF rotation to a dynamic image.\nfn apply_rotation(image: &mut DynamicImage, rotation: u32) {\n    use image::imageops as ops;\n    match rotation {\n        2 => ops::flip_horizontal_in_place(image),\n        3 => ops::rotate180_in_place(image),\n        4 => ops::flip_vertical_in_place(image),\n        5 => {\n            ops::flip_horizontal_in_place(image);\n            *image = image.rotate270();\n        }\n        6 => *image = image.rotate90(),\n        7 => {\n            ops::flip_horizontal_in_place(image);\n            *image = image.rotate90();\n        }\n        8 => *image = image.rotate270(),\n        _ => {}\n    }\n}\n```\n\nなんだこれ?  てかEXIFてなんだ……\n\nhttps://ja.wikipedia.org/wiki/Exchangeable_image_file_format\n\nどうやらEXIFというのは、写真自体がもっている90°回転やら鏡像やらのメタデータらしい。そしてこの関数はそのEXIF関数を使って写真を回転しているらしい。\n\n……これ、使えないか?\n\n90°回転や鏡像に限られてはいるけどレポートで使うのは精々そのぐらいだろうし、コンパイルの流れからも`Layout`より前の`[content]`生成の段階で画像に作用できるので、フレームワークの問題に衝突することもないだろう。かなりよさそうでは?\n\nとりあえずやってみよう。まずは`ImageElem`がどこで作られているかコールスタックをみていく。するとこんなものにたどりつく。\n\n```rust:typst/src/foundations/element.rs\nimpl Element {\n…\n    /// Construct an instance of this element.\n    pub fn construct(\n        self,\n        engine: &mut Engine,\n        args: &mut Args,\n    ) -> SourceResult<Content> {\n        (self.0.construct)(engine, args)\n    }\n…\n}\n```\n\nここで`ImageElem`を作っているようだ。 関数が`self`をとっているから`struct ImageElem`の中で型を完成させているらしい。 よってとりあえず`ImageElem`を変更していく。\n\n型定義をしている`mod.rs`に他のものに倣って`rotation`という引数を追加してみよう。 具体的にはこう↓\n```diff rust:typst/src/visualize/image/mod.rs\npub struct ImageElem {\n    #[required]\n    #[parse(\n        let Spanned { v: path, span } =\n            args.expect::<Spanned<EcoString>>(\"path to image file\")?;\n        let id = span.resolve_path(&path).at(span)?;\n        let data = engine.world.file(id).at(span)?;\n        path\n    )]\n    #[borrowed]\n    pub path: EcoString,\n\n    #[internal]\n    #[required]\n    #[parse(Readable::Bytes(data))]\n    pub data: Readable,\n\n    pub format: Smart<ImageFormat>,\n\n    pub width: Smart<Rel<Length>>,\n\n    pub height: Sizing,\n\n    pub alt: Option<EcoString>,\n\n    #[default(ImageFit::Cover)]\n    pub fit: ImageFit,\n\n+   #[default(1)] // FIXME: Added\n+   pub rotate: u32,  // FIXME: Added\n}\n```\n\nテストファイルはこのとおり\n\n```typst:test.typ\n#figure(\n    image(\"not_desired_behavior.png\", rotate: 5),\n    caption: \"Not desired behavior\"\n)\n```\n\nするとコンパイルしてもエラーを吐かなかった。\n\n次に、この`ImageElem`型を処理している関数を探す。するとすぐ下に`layout_image`がみつかる。\n\n```rust:typst/src/visualize/image/mod.rs\nfn layout_image(\n    elem: &Packed<ImageElem>,\n    engine: &mut Engine,\n    _: Locator,\n    styles: StyleChain,\n    region: Region,\n) -> SourceResult<Frame> {\n…\n}\n```\n\nここで、各`ImageElem`の要素が`elem.format(styles)`のように呼びだされていることがわかる。そこで、確認のため`println!(\"Rotate: {:?}\", elem.rotate(styles)); `として`rotate`が認識されているか確認する。すると、\n\n`Rotate: 5`\n\nという文面が出たため、ちゃんと認識されていることがわかる。\n\nさて、あとはこの引数をどうやって`apply_rotation`に渡すかだが、これのヒントとなったのが`raster.rs`以下の`RasterImage::new`にいた\n\n```rust:typst/src/visualize/image/raster.rs\n…\n        if let Some(rotation) = exif.as_ref().and_then(exif_rotation) {\n            apply_rotation(&mut dynamic, rotation);\n        }\n…\n```\n\nどうも`RasterImage::new`のタイミングで渡せばいいらしい。 あとは`new`がどこで呼ばれるかを見にいこう。\n\n```rust:typst/rc/visualize/image/mod.rs\nimpl Image {\n    pub fn new(\n        data: Bytes,\n        format: ImageFormat,\n        alt: Option<EcoString>,\n    ) -> StrResult<Image> {\n        let kind = match format {\n            ImageFormat::Raster(format) => {\n                ImageKind::Raster(RasterImage::new(data, format)?)\n            }\n            ImageFormat::Vector(VectorFormat::Svg) => {\n                ImageKind::Svg(SvgImage::new(data)?)\n            }\n        };\n\n        Ok(Self(Arc::new(LazyHash::new(Repr { kind, alt }))))\n    }\n\n    pub fn with_fonts(\n        data: Bytes,\n        format: ImageFormat,\n        alt: Option<EcoString>,\n        world: Tracked<dyn World + '_>,\n        families: &[&str],\n    ) -> StrResult<Image> {\n        let kind = match format {\n            ImageFormat::Raster(format) => {\n                ImageKind::Raster(RasterImage::new(data, format)?)\n            }\n            ImageFormat::Vector(VectorFormat::Svg) => {\n                ImageKind::Svg(SvgImage::with_fonts(data, world, families)?)\n            }\n        };\n        Ok(Self(Arc::new(LazyHash::new(Repr { kind, alt }))))\n    }\n}\n```\n\nいた。 ここで型が`Image`になっているのでどこかで`Image`型をつくっているはずである。それは先程の\n\n```rust:typst/rc/visualize/image/mod.rs\nfn layout_image(\n    elem: &Packed<ImageElem>,\n    engine: &mut Engine,\n    _: Locator,\n    styles: StyleChain,\n    region: Region,\n) -> SourceResult<Frame> {\n…\n    let image = Image::with_fonts(\n        data.clone().into(),\n        format,\n        elem.alt(styles),\n        engine.world,\n        &families(styles).collect::<Vec<_>>(),\n    )\n    .at(span)?;\n…\n}\n```\n\nで作られているのがわかる。\n\nあとは、それぞれに`rotate`引数を渡してみて、うまくいくかを確認する。\n\n```diff rust: typst/rc/visualize/image/mod.rs\n    let image = Image::with_fonts(\n        data.clone().into(),\n        format,\n        elem.alt(styles),\n        engine.world,\n        &families(styles).collect::<Vec<_>>(),\n+       elem.rotate(styles),\n    )\n    .at(span)?;\n```\n\n```diff rust: typst/rc/visualize/image/mod.rs\nimpl Image {\n    pub fn new(\n        data: Bytes,\n        format: ImageFormat,\n        alt: Option<EcoString>,\n    ) -> StrResult<Image> {\n        let kind = match format {\n            ImageFormat::Raster(format) => {\n-                ImageKind::Raster(RasterImage::new(data, format)?)\n+                ImageKind::Raster(RasterImage::new(data, format, 1)?)\n            }\n            ImageFormat::Vector(VectorFormat::Svg) => {\n                ImageKind::Svg(SvgImage::new(data)?)\n            }\n        };\n\n        Ok(Self(Arc::new(LazyHash::new(Repr { kind, alt }))))\n    }\n\n    pub fn with_fonts(\n        data: Bytes,\n        format: ImageFormat,\n        alt: Option<EcoString>,\n        world: Tracked<dyn World + '_>,\n        families: &[&str],\n+        rotation: u32,\n    ) -> StrResult<Image> {\n        let kind = match format {\n            ImageFormat::Raster(format) => {\n-                ImageKind::Raster(RasterImage::new(data, format)?)\n+                ImageKind::Raster(RasterImage::new(data, format, rotation)?)\n            }\n            ImageFormat::Vector(VectorFormat::Svg) => {\n                ImageKind::Svg(SvgImage::with_fonts(data, world, families)?)\n            }\n        };\n        Ok(Self(Arc::new(LazyHash::new(Repr { kind, alt }))))\n    }\n}\n```\n\n```diff rust: typst/src/visualize/image/raster.rs\nimpl RasterImage {\n    /// Decode a raster image.\n    #[comemo::memoize]\n-     pub fn new(data: Bytes, format: RasterFormat) -> StrResult<RasterImage> {\n+     pub fn new(data: Bytes, format: RasterFormat, rotation: u32) -> StrResult<RasterImage> {\n…\n        let exif = exif::Reader::new()\n            .read_from_container(&mut std::io::Cursor::new(&data))\n            .ok();\n\n+         apply_rotation(&mut dynamic, rotation);\n\n        // Apply rotation from EXIF metadata.\n        if let Some(rotation) = exif.as_ref().and_then(exif_rotation) {\n            apply_rotation(&mut dynamic, rotation);\n        }\n\n        // Extract pixel density.\n        let dpi = determine_dpi(&data, exif.as_ref());\n\n        Ok(Self(Arc::new(Repr { data, format, dynamic, icc, dpi })))\n    }\n}\n```\n\nさて、どうなるか。\n\n![crab_crab](https://storage.googleapis.com/zenn-user-upload/7a5d648f6edb-20241022.png)\n\n\n**やったーーー!**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    },
    {
      "author": "htsulfuric",
      "created_at": "2024-10-24",
      "body_markdown": "## 7日目\n\nとりあえずできたものはできたので、バグ潰し。\n\n\n### EXIFデータで既に回転が指定されているときに予想外の挙動をする。\n\n\nこれは割と簡単。 関数側の回転をEXIFデータによる回転の後においてあげる。\n```diff rust: typst/src/visualize/image/raster.rs\nimpl RasterImage {\n    /// Decode a raster image.\n    #[comemo::memoize]\n     pub fn new(data: Bytes, format: RasterFormat, rotation: u32) -> StrResult<RasterImage> {\n…\n        let exif = exif::Reader::new()\n            .read_from_container(&mut std::io::Cursor::new(&data))\n            .ok();\n\n-         apply_rotation(&mut dynamic, rotation);\n\n        // Apply rotation from EXIF metadata.\n        if let Some(rotation) = exif.as_ref().and_then(exif_rotation) {\n            apply_rotation(&mut dynamic, rotation);\n        }\n\n+         apply_rotation(&mut dynamic, rotation);\n\n        // Extract pixel density.\n        let dpi = determine_dpi(&data, exif.as_ref());\n\n        Ok(Self(Arc::new(Repr { data, format, dynamic, icc, dpi })))\n    }\n}\n```\n\n### 引数名が重複している\n\n引数がシャドーイングしていて気付いていなかった。(これrust的には便利な機能らしいのだが、まだあまりよさがわからない)\n\n```diff rust: typst/src/visualize/image/raster.rs\nimpl RasterImage {\n    /// Decode a raster image.\n    #[comemo::memoize]\n-     pub fn new(data: Bytes, format: RasterFormat, rotation: u32) -> StrResult<RasterImage> {\n+     pub fn new(data: Bytes, format: RasterFormat, my_rotation: u32) -> StrResult<RasterImage> {\n…\n        let exif = exif::Reader::new()\n            .read_from_container(&mut std::io::Cursor::new(&data))\n            .ok();\n\n        // Apply rotation from EXIF metadata.\n        if let Some(rotation) = exif.as_ref().and_then(exif_rotation) { // ここで引数が衝突してた\n            apply_rotation(&mut dynamic, rotation);\n        }\n\n-         apply_rotation(&mut dynamic, rotation);\n+         apply_rotation(&mut dynamic, my_rotation);\n\n        // Extract pixel density.\n        let dpi = determine_dpi(&data, exif.as_ref());\n\n        Ok(Self(Arc::new(Repr { data, format, dynamic, icc, dpi })))\n    }\n}\n```\n\nとりあえず以上。 これからの方針として\n\n- EXIFデータはu32で直感的理解がし辛いのでAngleとmirrorという引数にわける\n- vector imageに対するローテーションができないため、実装を考える\n- その他Typstに不満な点を探す\n- スライドを作る\n\n\n\n\n",
      "body_updated_at": "2024-10-24"
    },
    {
      "author": "htsulfuric",
      "created_at": "2024-10-28",
      "body_markdown": "## 8日目\n\n### Angleの実装\n\nそもそも`Angle`という型がTypstには用意されているので、それを見にいく。\n\n```rust: typst/src/layout/angle.rs\nimpl Angle {\n    /// The zero angle.\n    pub const fn zero() -> Self {\n        Self(Scalar::ZERO)\n    }\n\n    /// Create an angle from a number of raw units.\n    pub const fn raw(raw: f64) -> Self {\n        Self(Scalar::new(raw))\n    }\n\n……\n}\n```\n\n色々便利そうなので流用させてもらおう。 `Image`構造体の定義のところを書きかえていく\n\n```diff rust: typst/rc/visualize/image/mod.rs\n+ use crate::layout::Angle;\n…\n\npub struct ImageElem {\n    …\n\n-   #[default(1)] \n-   pub rotate: u32,\n+   #[default(Angle::zero())]\n+   pub rotate: Angle\n}\n…\n\nimpl Image {\n    …\n\n    pub fn new(\n        data: Bytes,\n        format: ImageFormat,\n        alt: Option<EcoString>,\n    ) -> StrResult<Image> {\n        let kind = match format {\n            ImageFormat::Raster(format) => {\n-                ImageKind::Raster(RasterImage::new(data, format, 1)?)\n+                ImageKind::Raster(RasterImage::new(data, format, Angle::zero())?)\n            }\n            ImageFormat::Vector(VectorFormat::Svg) => {\n                ImageKind::Svg(SvgImage::new(data)?)\n            }\n        };\n\n        Ok(Self(Arc::new(LazyHash::new(Repr { kind, alt }))))\n    }\n\n    pub fn with_fonts(\n        data: Bytes,\n        format: ImageFormat,\n        alt: Option<EcoString>,\n        world: Tracked<dyn World + '_>,\n        families: &[&str],\n-       rotation: u32,\n+       rotation: Angle,\n    ) -> StrResult<Image> {\n        let kind = match format {\n            ImageFormat::Raster(format) => {\n                 ImageKind::Raster(RasterImage::new(data, format, rotation)?)\n            }\n            ImageFormat::Vector(VectorFormat::Svg) => {\n                ImageKind::Svg(SvgImage::with_fonts(data, world, families)?)\n            }\n        };\n        Ok(Self(Arc::new(LazyHash::new(Repr { kind, alt }))))\n    }\n}\n```\n\n```diff rust: typst/rc/visualize/image/raster.rs\n+ use crate::layout::Angle;\n\nimpl RasterImage {\n    /// Decode a raster image.\n    #[comemo::memoize]\n    pub fn new(\n        data: Bytes,\n        format: RasterFormat,\n+       my_rotation: Angle, \n    ) -> StrResult<RasterImage> {\n        …\n        }\n}\n\n+ fn apply_user_rotation(image: &mut DynamicImage, rotation: Angle) {\n+     use image::imageops as ops;\n+     let rotation = rotation.to_deg() as u32;\n+     match rotation {\n+         90 => *image = image.rotate90(),\n+         180 => ops::rotate180_in_place(image),\n+         270 => *image = image.rotate270(),\n+         _ => {}\n+     }\n+}\n```\n\nと、すれば実装できる。\n\n### mirrorの実装\n先程とあまり変らない、とおもって構造体を実装するとこのようなエラーにぶつかった。\n\n\n```diff rust: typst/rc/visualize/image/mod.rs\n\npub struct ImageElem {\n    …\n\n    #[default(Angle::zero())]\n    pub rotate: Angle\n+   pub mirrot: &str // ■ missing lifetime specifier expected named lifetime parameter \n}\n```\n\nほーん? \n\nしかし実際`Typst`内で`&str`が呼ばれてるのをみたことは少ない。むしろ(謎)の`EcoString`という型がよく使われてる。ということで型を`EcoString`にしてあげると(なぜか)上手くいったため、以降そのように実装する。いつかライフタイムについては理解しよう。\n\n(余談だが、ImageElemは構造体要素に対してOption<T>を自動的に付けるため、ここでOptionを付ける必要はない(一敗))\n\n```diff rust: typst/rc/visualize/image/mod.rs\n\npub struct ImageElem {\n    …\n\n    #[default(Angle::zero())]\n    pub rotate: Angle\n    pub mirrot: EcoString\n}\n…\n\nfn layout_image(\n    elem: &Packed<ImageElem>,\n    engine: &mut Engine,\n    _: Locator,\n    styles: StyleChain,\n    region: Region,\n) -> SourceResult<Frame> {\n    …\n\n    let image = Image::with_fonts(\n        data.clone().into(),\n        format,\n        elem.alt(styles),\n        engine.world,\n        &families(styles).collect::<Vec<_>>(),\n        elem.rotate(styles), \n+       elem.mirror(styles), \n    )\n    .at(span)?;\n}\n\nimpl Image {\n    …\n\n    pub fn new(\n        data: Bytes,\n        format: ImageFormat,\n        alt: Option<EcoString>,\n    ) -> StrResult<Image> {\n        let kind = match format {\n            ImageFormat::Raster(format) => {\n                ImageKind::Raster(RasterImage::new(\n                    data,\n                    format,\n                    Angle::zero(),\n+                   EcoString::new(),\n                )?)\n                // FIXME: temporary implementation\n            }\n            ImageFormat::Vector(VectorFormat::Svg) => {\n                ImageKind::Svg(SvgImage::new(data)?)\n            }\n        };\n\n        Ok(Self(Arc::new(LazyHash::new(Repr { kind, alt }))))\n    }\n    …\n    pub fn with_fonts(\n        data: Bytes,\n        format: ImageFormat,\n        alt: Option<EcoString>,\n        world: Tracked<dyn World + '_>,\n        families: &[&str],\n        rotation: Angle, \n+       mirror: EcoString, \n    ) -> StrResult<Image> {\n        let kind = match format {\n            ImageFormat::Raster(format) => {\n-               ImageKind::Raster(RasterImage::new(data, format, rotation)?)\n+               ImageKind::Raster(RasterImage::new(data, format, rotation, mirror)?)\n                //FIXME: added rotation and mirror\n            }\n            ImageFormat::Vector(VectorFormat::Svg) => {\n                ImageKind::Svg(SvgImage::with_fonts(data, world, families)?)\n            }\n        };\n\n        Ok(Self(Arc::new(LazyHash::new(Repr { kind, alt }))))\n    }\n```\n\n```diff rust: typst/rc/visualize/image/raster.rs\nimpl RasterImage {\n    /// Decode a raster image.\n    #[comemo::memoize]\n    pub fn new(\n        data: Bytes,\n        format: RasterFormat,\n        my_rotation: Angle,\n+       my_mirror: EcoString,\n    ) -> StrResult<RasterImage> {\n        …\n        if let Some(rotation) = exif.as_ref().and_then(exif_rotation) {\n            apply_rotation(&mut dynamic, rotation);\n        }\n\n        apply_user_rotation(&mut dynamic, my_rotation);\n\n+       apply_user_mirror(&mut dynamic, my_mirror);\n        …\n        }\n}\n\n+fn apply_user_mirror(image: &mut DynamicImage, mirror: EcoString) {\n+    use image::imageops as ops;\n+    let mirror = mirror.as_str();\n+    match mirror {\n+        \"horizontal\" => {\n+            println!(\"mirror_horizontal\");\n+            ops::flip_horizontal_in_place(image);\n+        }\n+        \"vertical\" => {\n+            println!(\"mirror_vertical\");\n+            ops::flip_vertical_in_place(image);\n+        }\n+        _ => {\n+            println!(\"no mirror\");\n+        }\n+    }\n}\n\n```\n\nこれでうまくいった。 割とシンプル。\n\n### バグをみつけました!!!\n\nしかも結構やっかいなやつ。 とりあえず以下をみてほしい。\n\n```typst: test.typ\n\n#figure(\n    image(\"not_desired_behavior.png\"),\n    caption: [\n        Example Image\n    ],\n)\n\n#figure(\n    image(\"not_desired_behavior.png\", rotate: 90deg),\n    caption: [\n        Example Image\n    ],\n)\n```\n\n結果\n\n![what_the](https://storage.googleapis.com/zenn-user-upload/0a6ab3560bf1-20241024.png)\n*Huh?*\n\nなんじゃこりゃ。\n\n### 検証\nこれより前に、\n```typst: test\n#image(\"not_desired_behavior.png\", mirror: \"\")\n\n#image(\"not_desired_behavior.png\", mirror: \"horizontal\")\n```\nとしても、\n![kani_kani](https://storage.googleapis.com/zenn-user-upload/430b71574ff4-20241024.png)\n*みて!蟹がおどってるよ!*\n\n蟹の方向がかわらないというバグに遭遇はしていた。 上のバグがみつかるまでは実装の問題かなーと思っていたが、どうやら違いそうだとわかった。\n\nつまり、今回おこった(らしき)現象は\n\n1. 画像aの設定を読みこむ(ここまでは正常)\n2. 画像aの設定を再び読みこむとき、**画像自体に回転やら反転はおこらないが、フレームのみに適応される**\n3. そのままフレームにはまるように画像が適応され、歪んだりする\n\nということらしい。 なんでやねん。\n\n\n"
    },
    {
      "author": "htsulfuric",
      "created_at": "2024-10-29",
      "body_markdown": "## 9日目\n\nバグ取りはあきらめスライド作成へ勤しんだ..."
    }
  ]
}