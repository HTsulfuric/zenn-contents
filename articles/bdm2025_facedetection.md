---
title: "ESP32-S3を用いたメガネ装着型カメラモジュール"
emoji: "👓"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["ESP32", "顔認証", "Python"]
published: true
---

# はじめに

この記事は2024年に開催された電気情報機器学(BDM)の最終課題作成の備忘録です。また、2025年五月祭のEEIC企画で展示されていた同作品の詳細記事でもあります。

# やりたかったこと

**人の顔が覚えられない！** ええ、これはもう、私の人間としての根本的な問題でしかありません。初対面の人と話すとき、数分後には「あれ、この人誰だっけ？」となることもしばしば。せっかくなので、私の人間的成長という茨の道以外の手段で、この切実な悩みを解決してみたくなりました。
そこで、「人の顔を覚える、認識する」という、人間にとってごく自然な行為を、いっそ外部に丸投げしてしまえばいいのではないか、という壮大な（？）モチベーションでこのプロジェクトは作成されました。
最終的には、ESP32-S3をメガネに装着できる小型カメラモジュールとして活用し、PC側で顔認証を行い、その結果をLINE Notifyで通知するという、まるでSF映画のような（？）システムを構築しました。

# 使用したもの

## XIAO ESP32-S3 Sense

メガネに装着するとなると、やはり小型軽量は絶対条件。そこで白羽の矢が立ったのがESP32です。XIAO ESP32-S3 SenseとESP32-CAMが標準でカメラ（OV2640CMOS等）を搭載するポートを備えていたため、候補に挙がりました。スペック比較は海外の猛者がYouTubeに上げてくださっていたので、そちらを参考にさせていただきました。

https://youtu.be/gYQDGoVRObA?si=RuicvLGegs6WKI7H

結論として、どちらもESP32-S3を搭載していますが、XIAO ESP32-S3 Sense側には8MBのフラッシュが搭載されているのに対し、ESP32-CAM側は4MBのフラッシュしか搭載されていないため、XIAO ESP32-S3 Senseを選択しました。ただし、XIAO ESP32-S3 Senseは小型である分、発熱がかなりのもので、まるでカイロのようでした。また、付属のアンテナ以外で技適を取得しているか不明なため、その点を考慮しながら、まるで爆弾を扱うかのように慎重に使用する必要がありました。

:::message
以降、簡略のため、XIAO ESP32-S3 Senseを「ESP32」と呼ぶことにします。
:::

## MacBook Air(M1)

顔認証をして、それをLINE Notifyで通知したかったため、PC側でPythonを使用して顔認証を行うこととしました。顔認証には、もはや顔認証界のデファクトスタンダードとも言える`face_recognition`というライブラリを使用。これを使えば、顔認証のための学習も、顔認識も、まるで魔法のように実現できます。

## 3Dプリンタ

顔に装着するからには、メガネにスマートにひっかける「籠」のようなものが必要不可欠。そこで、学内の3Dプリンタをフル活用し、まるで職人のように（？）設計・出力しました。

## その他

- Gemini

最近無料になっていたので、デスマーチと化したBDMで生まれた「かなり汚いコード」のリファクタリングに、まるで救世主のように使ってみました。

# コード

https://github.com/HTsulfuric/face_recognition

`firmware/`以下にESP32の魂とも言えるコードが、その他はPythonの脳みそとも言えるコードが書かれています。以下、それぞれのコードの軽い説明を行います。

## ESP32側のコード

基本的にはESP32のお試しライブラリのなかにあるCameraWebServerを参考にしました。まるで教科書のように。

https://github.com/RuiSantosdotme/arduino-esp32-CameraWebServer

変更点としては、

- XIAO ESP32 以外のボード用のコードを削除（Face_detection.ino, camera_pins.h）。まるで不要な脂肪を削ぎ落とすかのように。
- HTTPではなくWebSocketを用いることで、双方向での通信が容易になりました（app_https.cpp）。これでPCとESP32がまるで友達のように会話できます。

WebSocketの関数などをArduino IDEのライブラリでAsync WebServerから持ってくることができたため、ESP32側のコードはあまり難しくありませんでした。まるでパズルを組み立てるように。

以下、起動後のESP32側のコードの流れを示します。

1.  ESP32の起動
    起動するとまずWiFiに接続。WiFiのSSIDとパスはハードコーディングされています。まるで秘密の呪文のように。
2.  WiFiに接続するとHTTPサーバーを起動します。この時点ではカメラは起動していないため、サーバーのタスクのみが起動しています。まるで開店準備中の店のように。
3.  WebSocketの接続があり、かつWebSocket越しから"start_stream"のメッセージが来ると、カメラを初期化し、ストリーミングを開始します。まるで合図を待っていたかのように。
4.  ストリーミング中は、WebSocket越しに"stop_stream"のメッセージが来るまで、カメラから取得した画像をJPEG形式でPC側に送信します。まるで専属カメラマンのように。
5.  "stop_stream"のメッセージが来ると、カメラを停止し、psramを解放します。WebSocketの接続が切れた場合も同様に処理します。まるで任務を終えたエージェントのように。

## Python側のコード

GUI(Tkinter)、Websocket、Face_recognitionの3つを動かします。Tkinterはメインスレッドで動かし、WebSocketとFace_recognitionを別スレッドで動かすようにしました。これにより、Tkinterのメインスレッドがブロックされることなく、リアルタイムで顔認識を行うことができました。まるでオーケストラの指揮者のように。

以下、Python側のコードの流れを示します。

1.  Appの起動 `main()`
    起動するとまず環境変数の読み込みを行い、その後Tkinterのrootを作成し、その後Appクラスを作成します。まるで舞台の幕開けのように。
2.  Appクラスの初期化 `__init__`
    Appクラスの初期化では、Tkinterのウィンドウを作成し、既存の顔データの読み込み、`logger`のセットアップ、WebSocketインスタンスの作成などを行います。まるで準備万端の探偵のように。
3.  キューの作成
    WebSocketとTkinterでは別スレッドで動作するため、データ処理を杜撰に行うとSIGSEGVが発生します。これを抑制するため、logデータやfpsデータはキューを使用してメインスレッドに渡し、画像データは`threading.Lock`に格納して安全にデータをやり取りするようにしました。まるで交通整理をするかのように。
4.  WebSocketの接続 `start_process()`
    GUI上で接続ボタンを押すと、WebSocketの接続を行います。接続が成功すると、ESP32側に"start_stream"のメッセージを送信し、カメラのストリーミングを開始します。まるで合図を送るかのように。
5.  ストリーミングの開始 `_on_websocket_message`
    ストリーミングが開始されると、ESP32側からJPEG形式の画像データが送信されてきます。これを受信すると同スレッド上で顔認証を開始します。また、ESP32から文章形式のデータが送信されてくる場合もあるため、これを受信した場合はloggerに出力します。まるで情報を受け取る司令官のように。
6.  顔認証 `face_recognition`
    受信したJPEG形式の画像データをopenCVでnumpy配列に変換し、グレースケールに変換するなどの処理を施した後、`face_recognition`ライブラリを使用して顔認証を行います。認識した顔の位置や名前を取得し、受信した画像の上に短形を描画して`self.latest_frame`に保存します。また認識した顔の名前をLINE Notifyで通知します。まるで名探偵のように。
7.  GUIの更新 `update_image()`
    `self.latest_frame`に格納された画像データをメインスレッドでTkinterのウィンドウに表示します。これにより、リアルタイムで顔認識の結果を確認することができます。まるでライブ中継のように。

# 実装が大変だった点

## ESP32側

-   **Arduino IDE の使いづらさ**:
    PSRAMを起動するためにArduino IDEのオプションを選択しないといけないのが、まるで隠しコマンドのようで分かりづらい！ また最近になってAsyncWebServerのライブラリが破壊的変更されていたため、ESP32のコードが動かなくなり、まるで突然の裏切りに遭った気分でした。

## Python側

-   **Tkinterによる謎のSIGSEGV**:
    Tkinterはスレッドセーフではないため、メインスレッドで動かす必要がある。これにより、WebSocketの受信処理とTkinterのUI更新処理を別スレッドで行う必要があり、データのやり取りにキューを使用する必要がありました。これが開発当初知らなかったため、まるで呪いのように謎のSIGSEGVに悩まされました。

# 課題点

## ESP32側

-   発熱の問題

5分程度の稼働でもESP32が熱くなりすぎてWiFIが切断されることがありました。まるで熱暴走したロボットのように。また、HTTPサーバーの起動はそのままに、カメラを休止させようとしたのですが、それに必要なピン（PWDN端子）がGPIOに割り当てられていなかったため、カメラを休止させることができませんでした。まるで休むことを許されない兵士のように。

詳しくは以下参照
https://forum.seeedstudio.com/t/xiao-esp32s3-sense-camera-sleep-current/271258/5?page=4

-   アンテナの問題

Xiao ESP32 Senseは技適の都合で付属のアンテナ以外で使用することができないため、ESP32-CAMを使用した場合と比べて通信距離が短くなってしまいました。これにより、PC側からの通信が途切れやすくなってしまい、まるで糸の切れた凧のようでした。

:::details 現実的でない解決方法
電波法に基づくと、電波暗室内においては技適のないアンテナを使用しても問題ない。実際、筆者が電波暗室においてアンテナに鉄でできたクリップをつけて使用したところ、通信が大幅に改善された。しかし、電波暗室内で相手の顔がわからなくなるケースがあるとは思えないため、実用的ではない。まるで砂漠で水を探すようなものですね。
:::

## Python側

-   **デザイン**:
    Tkinterダサい。もう一言で片付けられるレベルでダサい。まるで昭和の遺産。
-   **顔認証の登録**:
    現状はファイル直下に画像を直置きして、ファイル名で名前を指定する形になっていますが、これだと画像の管理が大変です。まるで散らかった部屋のよう。ちゃんとDBなどで管理して、アクセスも高速にしたい。また、現状だと画像の新規登録時はUnknownで登録し、後で名前を変更する必要があるのですが、これも面倒です。まるで二度手間。新規登録時に名前を指定できるようにしたい。
-   **通知の問題**:
    LINE Notifyは便利かつ簡単でよかったのですが、まさかのサービス終了。まるで突然の別れ。代替案として、SlackやDiscordのWebhookなどがあるので、いつか実装したい。折角ならそこへ返信することで新規画像の名前登録などできれば、まるで秘書のように便利になるなと思っています。

# まとめ

ESP32-S3を用いたメガネ装着型カメラモジュールと、PythonによるPC側での顔認証システムを構築しました。人の顔を覚えるという個人的な課題を技術で解決するという、まるで私のためだけに作られたかのような（？）モチベーションから始まり、小型軽量なデバイス選定、WebSocketによるリアルタイム通信、そして`face_recognition`ライブラリを用いた顔認証の実装に挑戦しました。

上記のような問題はあれど、少なくとも動くものが自分で実装できたのはやっぱり嬉しいですね。まるで初めて自転車に乗れた時のように。実際の発表の場では少々トラブルに見舞われましたが、最終的には無事に発表でき、成績も優をいただきました。これからもこういう工作をやりたいですね。まるで飽くなき探求者のように。

:::message
BDMは2人以上のチームで行なうことを推奨します。 いやほんとに。 1人でやるとデスマーチになりますし、誰も愚痴を聞いてくれません。まるで孤独な戦士。
:::
